using EducationCourseManagement.Data;
using EducationCourseManagement.DTOs;
using EducationCourseManagement.Models;
using EduCourseManagementAPI.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace EducationCourseManagement.Services
{
    public class ScheduleService : IScheduleService
    {
        private readonly SchoolContext _context;

        public ScheduleService(SchoolContext context)
        {
            _context = context;
        }

        // Get all schedules
        public async Task<IEnumerable<ScheduleDTO>> GetAllSchedulesAsync()
        {
            try
            {
                var schedules = await _context.Schedules
                    .Include(s => s.Course)
                    .Include(s => s.Instructor)
                    .Include(s => s.Room)
                    .ToListAsync();

                return schedules.Select(s => new ScheduleDTO
                {
                    ScheduleId = s.ScheduleId,
                    CourseId = s.CourseId,
                    InstructorId = s.InstructorId,
                    RoomId = s.RoomId,
                    Date = s.Date,
                    TimeSlot = s.TimeSlot
                });
            }
            catch (Exception ex)
            {
                throw new Exception($"Error fetching all schedules: {ex.Message}", ex);
            }
        }

        // Get schedule by ID
        public async Task<ScheduleDTO> GetScheduleByIdAsync(int id)
        {
            try
            {
                var schedule = await _context.Schedules
                    .Include(s => s.Course)
                    .Include(s => s.Instructor)
                    .Include(s => s.Room)
                    .FirstOrDefaultAsync(s => s.ScheduleId == id);

                if (schedule == null)
                    throw new KeyNotFoundException($"Schedule with ID {id} not found.");

                return new ScheduleDTO
                {
                    ScheduleId = schedule.ScheduleId,
                    CourseId = schedule.CourseId,
                    InstructorId = schedule.InstructorId,
                    RoomId = schedule.RoomId,
                    Date = schedule.Date,
                    TimeSlot = schedule.TimeSlot
                };
            }
            catch (Exception ex)
            {
                throw new Exception($"Error fetching schedule by ID {id}: {ex.Message}", ex);
            }
        }

        // Create a new schedule
        public async Task<ScheduleResponse> CreateScheduleAsync(ScheduleDTO scheduleDTO)
        {
            try
            {
                var (isConflict, message, existingSchedule, suggestedTimeSlots) = await ValidatedScheduleAsync(
                    scheduleDTO.CourseId,
                    scheduleDTO.InstructorId,
                    scheduleDTO.RoomId,
                    scheduleDTO.Date,
                    scheduleDTO.TimeSlot
                );

                if (isConflict)
                {
                    return new ScheduleResponse
                    {
                        Success = false,
                        Message = message,
                        ExistingSchedule = existingSchedule != null ? new ScheduleDTO
                        {
                            ScheduleId = existingSchedule.ScheduleId,
                            CourseId = existingSchedule.CourseId,
                            InstructorId = existingSchedule.InstructorId,
                            RoomId = existingSchedule.RoomId,
                            Date = existingSchedule.Date,
                            TimeSlot = existingSchedule.TimeSlot
                        } : new ScheduleDTO(),
                        SuggestedTimeSlots = suggestedTimeSlots ?? new List<string>()
                    };
                }

                var schedule = new Schedule
                {
                    CourseId = scheduleDTO.CourseId,
                    InstructorId = scheduleDTO.InstructorId,
                    RoomId = scheduleDTO.RoomId,
                    Date = scheduleDTO.Date,
                    TimeSlot = scheduleDTO.TimeSlot,
                    IsAutoGenerated = scheduleDTO.IsAutoGenerated,
                    GeneratedBy = scheduleDTO.GeneratedBy
                };

                _context.Schedules.Add(schedule);
                await _context.SaveChangesAsync();

                return new ScheduleResponse
                {
                    Success = true,
                    Message = "Schedule created successfully.",
                    CreatedSchedule = new ScheduleDTO
                    {
                        ScheduleId = schedule.ScheduleId,
                        CourseId = schedule.CourseId,
                        InstructorId = schedule.InstructorId,
                        RoomId = schedule.RoomId,
                        Date = schedule.Date,
                        TimeSlot = schedule.TimeSlot,
                        IsAutoGenerated = schedule.IsAutoGenerated,
                        GeneratedBy = schedule.GeneratedBy
                    }
                };
            }
            catch (Exception ex)
            {
                throw new Exception($"Error creating schedule: {ex.Message}", ex);
            }
        }

        // Update an existing schedule
        public async Task<bool> UpdateScheduleAsync(int id, ScheduleDTO scheduleDTO)
        {
            try
            {
                var existingSchedule = await _context.Schedules.FindAsync(id);
                if (existingSchedule == null)
                    throw new KeyNotFoundException($"Schedule with ID {id} not found.");

                var hasConflict = await _context.Schedules.AnyAsync(s =>
                    s.Date.Date == scheduleDTO.Date.Date &&
                    s.TimeSlot == scheduleDTO.TimeSlot &&
                    (s.RoomId == scheduleDTO.RoomId ||
                     s.InstructorId == scheduleDTO.InstructorId ||
                     s.CourseId == scheduleDTO.CourseId) &&
                    s.ScheduleId != id);

                if (hasConflict)
                    throw new InvalidOperationException("The updated schedule conflicts with an existing schedule.");

                existingSchedule.CourseId = scheduleDTO.CourseId;
                existingSchedule.InstructorId = scheduleDTO.InstructorId;
                existingSchedule.RoomId = scheduleDTO.RoomId;
                existingSchedule.Date = scheduleDTO.Date;
                existingSchedule.TimeSlot = scheduleDTO.TimeSlot;

                _context.Schedules.Update(existingSchedule);
                await _context.SaveChangesAsync();

                return true;
            }
            catch (Exception ex)
            {
                throw new Exception($"Error updating schedule with ID {id}: {ex.Message}", ex);
            }
        }

        // Delete a schedule by ID
        public async Task<bool> DeleteScheduleAsync(int id)
        {
            try
            {
                var schedule = await _context.Schedules.FindAsync(id);
                if (schedule == null)
                    throw new KeyNotFoundException($"Schedule with ID {id} not found.");

                _context.Schedules.Remove(schedule);
                await _context.SaveChangesAsync();

                return true;
            }
            catch (Exception ex)
            {
                throw new Exception($"Error deleting schedule with ID {id}: {ex.Message}", ex);
            }
        }

        // Intelligent Schdulling (Validate Schedule)
        public async Task<(bool IsConflict, string Message, Schedule ExistingSchedule, List<string> SuggestedTimeSlots)> ValidatedScheduleAsync(
            int courseId, int instructorId, int roomId, DateTime date, string timeSlot)
        {
            try
            {
                var conflictingSchedule = await _context.Schedules.FirstOrDefaultAsync(s =>
                    s.Date.Date == date.Date &&
                    s.TimeSlot == timeSlot &&
                    (s.RoomId == roomId || s.InstructorId == instructorId || s.CourseId == courseId));

                if (conflictingSchedule != null)
                {
                    var allTimeSlots = new List<string>
                    {
                        "9:00 AM - 10:30 AM", "10:30 AM - 12:00 PM",
                        "1:00 PM - 2:30 PM", "2:30 PM - 4:00 PM"
                    };

                    var bookedTimeSlots = await _context.Schedules
                        .Where(s => s.Date.Date == date.Date)
                        .Select(s => s.TimeSlot)
                        .ToListAsync();

                    var availableTimeSlots = allTimeSlots.Except(bookedTimeSlots).ToList();

                    return (true, "Conflict detected. Please adjust the schedule.", conflictingSchedule, availableTimeSlots);
                }

                return (false, "No conflict detected.", null, null);
            }
            catch (Exception ex)
            {
                throw new Exception($"Error validating schedule: {ex.Message}", ex);
            }
        }
    }
}
